"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[78941],{78941:(e,i,s)=>{s.r(i),s.d(i,{default:()=>u});var a=s(50076),r=s(28383),n=s(90494),t=s(42633),l=s(11563);async function u(e){const{layerAdapter:i,...s}=await async function(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new a.default("unique-values:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");const i=e.valueExpression||e.sqlExpression,s=i&&!e.sqlExpression;if(i)if(s){if(!e.view)throw new a.default("unique-values:missing-parameters","View is required when 'valueExpression' is specified")}else if(!e.valueExpression)throw new a.default("unique-values:missing-parameters","'valueExpression' parameters are required");e.forBinning&&(0,n.p)(e,"unique-values");const{layer:u,...o}=e,f=e.forBinning?l.Mi:l.G3,p=(0,l.Jg)(u,f,e.forBinning);if(!p)throw new a.default("unique-values:invalid-parameters","'layer' must be one of these types: "+(0,l.Ho)(f).join(", "));const d={layerAdapter:p,...o},w=null!=d.signal?{signal:d.signal}:null;await p.load(w);const v=await(0,t.EG)({field:d.field,field2:d.field2,field3:d.field3,valueExpression:d.valueExpression}),m=(0,r.MH)(p,v,"unique-values:invalid-parameters");if(m)throw m;d.filter&&!d.filter.spatialRelationship&&(d.filter.spatialRelationship="intersects");const c=(0,r.Wk)(d.filter,"summary-statistics:invalid-parameters");if(c)throw c;return d}(e);return i.uniqueValues(s)}},90494:(e,i,s)=>{s.d(i,{p:()=>n,z:()=>r});var a=s(50076);const r="aggregateCount";function n(e,i){if(!e.view)throw new a.default(`${i}:missing-parameters`,"'view' parameter is required for binning");if(e.sqlExpression)throw new a.default(`${i}:invalid-parameters`,"'sqlExpression' parameter is not supported for binning");if("3d"===e.view.type)throw new a.default(`${i}:invalid-parameters`,"3d view is not supported for binning")}}}]);
//# sourceMappingURL=78941.ad4116d9.chunk.js.map