"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[6515,20873,28896],{6515:(e,t,i)=>{i.r(t),i.d(t,{default:()=>h});var n=i(35143),s=i(91967),l=i(50076),r=i(76460),a=i(46053),o=(i(81806),i(47249),i(85842));let u=class extends s.default{constructor(e){super(e),this.precision=4,this.thumbsConstrained=!0}set effectiveMax(e){this.setEffectiveMax(e)}set effectiveMin(e){this.setEffectiveMin(e)}set labelFormatFunction(e){this._set("labelFormatFunction",e)}set inputFormatFunction(e){this._set("inputFormatFunction",e)}set inputParseFunction(e){this._set("inputParseFunction",e)}get labels(){const{max:e,min:t,values:i}=this,n=i?.length?i.map(((e,t)=>this.getLabelForValue(e,"value",t))):[];return{max:this.getLabelForValue(e,"max"),min:this.getLabelForValue(t,"min"),values:n}}set max(e){this.setMax(e)}set min(e){this.setMin(e)}get state(){const{max:e,min:t}=this;return null!=e&&null!=t&&e>t?"ready":"disabled"}set values(e){const{max:t,min:i}=this,n=this.values;n&&e&&n.length===e.length&&n.every(((t,i)=>t===e[i]))||(this._set("values",null),e?.length&&(null!=i&&e.some((e=>e<i))&&(this.min=Math.min(...e)),null!=t&&e.some((e=>e>t))&&(this.max=Math.max(...e))),this._set("values",e))}toPrecision(e){return parseFloat(e.toFixed(this.precision))}defaultLabelFormatFunction(e){const{max:t,min:i,precision:n}=this,s=null!=t&&null!=i&&t-i>10?2:n;return parseFloat(e.toFixed(s)).toString()}defaultInputFormatFunction(e){return e.toString()}defaultInputParseFunction(e){return parseFloat(e)}getBounds(){const{effectiveMax:e,effectiveMin:t,max:i,min:n}=this;return{min:null!=t&&null!=n?Math.max(n,t):n,max:null!=e&&null!=i?Math.min(i,e):i}}getBoundsForValueAtIndex(e){const{thumbsConstrained:t,values:i}=this,{min:n,max:s}=this.getBounds();if(t&&i){const t=e-1,l=e+1;return{min:null!=i[t]?i[t]:n,max:null!=i[l]?i[l]:s}}return{min:n,max:s}}getLabelForValue(e,t,i){return null==e?null:this.labelFormatFunction?this.labelFormatFunction(e,t,i):this.defaultLabelFormatFunction(e)}setMax(e){const{max:t,values:i}=this;if(null==e)return void this._set("max",null);if(isNaN(e))return void this._logError("slider:invalid-value","Supplied value for property 'max' is NaN.");const n=this.toPrecision(e);if(t!==n&&(this._set("max",n),i?.length))for(let s=0;s<i.length;s++)n<i[s]&&this.setValue(s,n)}setMin(e){const{min:t,values:i}=this;if(null==e)return void this._set("min",null);if(isNaN(e))return void this._logError("slider:invalid-value","Supplied value for property 'min' is NaN.");const n=this.toPrecision(e);if(t!==n&&(this._set("min",n),i?.length))for(let s=0;s<i.length;s++)n>i[s]&&this.setValue(s,n)}setEffectiveMax(e){if(null==e)return void this._set("effectiveMax",null);if(isNaN(e))return void this._logError("slider:invalid-value","Supplied value for property 'effectiveMax' is NaN.");const t=this.toPrecision(e);this.effectiveMax!==t&&this._set("effectiveMax",this._applyBoundsToValue(t))}setEffectiveMin(e){if(null==e)return void this._set("effectiveMin",null);if(isNaN(e))return void this._logError("slider:invalid-value","Supplied value for property 'effectiveMin' is NaN.");const t=this.toPrecision(e);this.effectiveMin!==t&&this._set("effectiveMin",this._applyBoundsToValue(t))}setValue(e,t){if(isNaN(t))return void this._logError("slider:invalid-value","Supplied value for member of property 'values' is NaN.");const{values:i}=this;if(null==i)return void this._logError("slider:invalid-value","Supplied value for member of property 'values' is null.");const n=i[e],s=this.toPrecision(t);if(n===s)return;const l=[...i];l[e]=s,this._set("values",l),this.notifyChange("labels")}_applyBoundsToValue(e){const{max:t,min:i}=this;return null!=i&&e<i?i:null!=t&&e>t?t:e}_logError(e,t,i){r.A.getLogger(this).error(new l.default(e,t,i))}};(0,n._)([(0,a.MZ)()],u.prototype,"effectiveMax",null),(0,n._)([(0,a.MZ)()],u.prototype,"effectiveMin",null),(0,n._)([(0,a.MZ)()],u.prototype,"labelFormatFunction",null),(0,n._)([(0,a.MZ)()],u.prototype,"inputFormatFunction",null),(0,n._)([(0,a.MZ)()],u.prototype,"inputParseFunction",null),(0,n._)([(0,a.MZ)({readOnly:!0})],u.prototype,"labels",null),(0,n._)([(0,a.MZ)()],u.prototype,"max",null),(0,n._)([(0,a.MZ)()],u.prototype,"min",null),(0,n._)([(0,a.MZ)()],u.prototype,"precision",void 0),(0,n._)([(0,a.MZ)({readOnly:!0})],u.prototype,"state",null),(0,n._)([(0,a.MZ)()],u.prototype,"thumbsConstrained",void 0),(0,n._)([(0,a.MZ)()],u.prototype,"values",null),u=(0,n._)([(0,o.$)("esri.widgets.Slider.SliderViewModel")],u);const h=u},20873:(e,t,i)=>{i.r(t),i.d(t,{default:()=>u});var n=i(35143),s=i(46053),l=(i(81806),i(76460),i(47249),i(85842)),r=i(6515),a=i(7095);let o=class extends r.default{constructor(e){super(e),this.average=null,this.bins=null,this.hasTimeData=!1,this.labelFormatFunction=e=>{if(this.hasTimeData)return(0,a.formatDateLabel)(e);const{max:t,min:i,precision:n}=this,s=t-i>10?2:n;return(0,a.formatNumberLabel)(parseFloat(e.toFixed(s)))},this.rangeType="equal",this.standardDeviation=null}generateWhereClause(e){const{rangeType:t,state:i,values:n}=this;if("ready"!==i||!n?.length||null==e)return null;const s=n[0],l=n.length>1?n[n.length-1]:null;switch(t){case"equal":return`${e} = ${s}`;case"not-equal":return`${e} <> ${s}`;case"less-than":return`${e} < ${s}`;case"greater-than":return`${e} > ${s}`;case"at-least":return`${e} >= ${s}`;case"at-most":return`${e} <= ${s}`;case"between":return`${e} BETWEEN ${s} AND ${l}`;case"not-between":return`${e} NOT BETWEEN ${s} AND ${l}`;default:return null}}};(0,n._)([(0,s.MZ)()],o.prototype,"average",void 0),(0,n._)([(0,s.MZ)()],o.prototype,"bins",void 0),(0,n._)([(0,s.MZ)()],o.prototype,"hasTimeData",void 0),(0,n._)([(0,s.MZ)()],o.prototype,"labelFormatFunction",void 0),(0,n._)([(0,s.MZ)()],o.prototype,"rangeType",void 0),(0,n._)([(0,s.MZ)()],o.prototype,"standardDeviation",void 0),o=(0,n._)([(0,l.$)("esri.widgets.HistogramRangeSlider.HistogramRangeSliderViewModel")],o);const u=o}}]);
//# sourceMappingURL=20873.029a4e72.chunk.js.map