"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[7137,13481,29518,51899],{7137:(e,t,n)=>{n.r(t),n.d(t,{InverseGeodeticSolverResult:()=>y,directGeodeticSolver:()=>R,geodesicAreas:()=>M,geodesicCompatibleSpatialReference:()=>S,geodesicDensify:()=>w,geodesicDistance:()=>z,geodesicLengths:()=>v,inverseGeodeticSolver:()=>b,isSupported:()=>m,pointFromDistance:()=>q});var i=n(50076),s=n(31633),a=n(40565),r=n(19247),o=n(65215),l=n(23701),u=n(13312),c=n(63885),h=n(80963);function f(e){if(!e)return null;const t=e.wkid;if(t)return c.uw[t];const n=e.wkt2??e.wkt;return n?function(e){const t=c._f.exec(e);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),s=parseFloat(n[2]);return isNaN(i)||isNaN(s)?null:{a:i,f:0===s?0:1/s}}(n):null}function p(e){const t=f(e);if(function(e){return null!=e&&"b"in e&&"eSq"in e&&"radius"in e}(t))return t;const n=t.a*(1-t.f);return Object.assign(t,{b:n,eSq:1-(n/t.a)**2,radius:(2*t.a+n)/3,densificationRatio:1e4/((2*t.a+n)/3)})}function d(e){return null!=e&&e<0?e+360:e}function g(e,t,n){const{a:i,eSq:s}=p(n),a=Math.sqrt(s),r=Math.sin(t[1]*c.eh),o=i*t[0]*c.eh;let l;return l=s>0?i*((1-s)*(r/(1-s*(r*r))-1/(2*a)*Math.log((1-a*r)/(1+a*r))))*.5:i*r,e[0]=o,e[1]=l,e}function m(e){return(0,h.EA)(e)&&!!f(e)}function M(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"square-meters";if(e.some((e=>!m(e.spatialReference))))throw new i.default("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const t=e[i],s=t.spatialReference,{radius:a,densificationRatio:r}=p(s),o=a*r;n.push(w(t,o))}const a=[],r=[0,0],o=[0,0];for(let i=0;i<n.length;i++){const{rings:e,spatialReference:l}=n[i];let u=0;for(let t=0;t<e.length;t++){const n=e[t];g(r,n[0],l),g(o,n[n.length-1],l);let i=o[0]*r[1]-r[0]*o[1];for(let e=0;e<n.length-1;e++)g(r,n[e+1],l),g(o,n[e],l),i+=o[0]*r[1]-r[0]*o[1];u+=i}u=(0,s.oU)(u,"square-meters",t),a.push(u/-2)}return a}function v(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"meters";if(!e)throw new i.default("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some((e=>!m(e.spatialReference))))throw new i.default("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const a=e[i],{spatialReference:r}=a,o="polyline"===a.type?a.paths:a.rings;let l=0;for(let e=0;e<o.length;e++){const t=o[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],s=t[e][0],a=t[e-1][1],o=t[e][1];if(a!==o||i!==s){const e=new y;b(e,[i,a],[s,o],r),n+=e.distance}}l+=n}l=(0,s.oU)(l,"meters",t),n.push(l)}return n}function w(e,t){if("polyline"!==e.type&&"polygon"!==e.type)throw new i.default("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=e;if(!m(n))throw new i.default("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s="polyline"===e.type?e.paths:e.rings,r=[],c=[0,0],h=new y;for(const i of s){const e=[];r.push(e),e.push([i[0][0],i[0][1]]);let s,a,o=i[0][0],l=i[0][1];for(let r=0;r<i.length-1;r++){if(s=i[r+1][0],a=i[r+1][1],o===s&&l===a)continue;const u=[o,l];b(h,[o,l],[s,a],n);const{azimuth:f,distance:p}=h,d=p/t;if(d>1){for(let i=1;i<=d-1;i++)R(c,u,f,i*t,n),e.push(c.slice());R(c,u,f,(p+Math.floor(d-1)*t)/2,n),e.push(c.slice())}R(c,u,f,p,n),e.push(c.slice()),o=c[0],l=c[1]}}const f=(0,a.PZ)(u.default,n);return"polyline"===e.type?new l.default({paths:r,spatialReference:f}):new o.default({rings:r,spatialReference:f})}class y{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.distance=e,this.azimuth=t,this.reverseAzimuth=n}}function R(e,t,n,i,s){const a=t[0],r=t[1],o=a*c.eh,l=r*c.eh,u=(n??0)*c.eh,{a:h,b:f,f:d}=p(s),g=Math.sin(u),m=Math.cos(u),M=(1-d)*Math.tan(l),v=1/Math.sqrt(1+M*M),w=M*v,y=Math.atan2(M,m),R=v*g,b=R*R,z=1-b,q=z*(h*h-f*f)/(f*f),S=1+q/16384*(4096+q*(q*(320-175*q)-768)),_=q/1024*(256+q*(q*(74-47*q)-128));let k,A,E,x=i/(f*S),N=2*Math.PI;for(;Math.abs(x-N)>1e-12;)E=Math.cos(2*y+x),k=Math.sin(x),A=Math.cos(x),N=x,x=i/(f*S)+_*k*(E+_/4*(A*(2*E*E-1)-_/6*E*(4*k*k-3)*(4*E*E-3)));const P=w*k-v*A*m,Z=Math.atan2(w*A+v*k*m,(1-d)*Math.sqrt(b+P*P)),C=d/16*z*(4+d*(4-3*z)),D=Math.atan2(k*g,v*A-w*k*m)-(1-C)*d*R*(x+C*k*(E+C*A*(2*E*E-1)));return e[0]=(o+D)/c.eh,e[1]=Z/c.eh,e}function b(e,t,n,i){const s=t[0]*c.eh,a=t[1]*c.eh,r=n[0]*c.eh,o=n[1]*c.eh,{a:l,b:u,f:h,radius:f}=p(i),d=r-s,g=Math.atan((1-h)*Math.tan(a)),m=Math.atan((1-h)*Math.tan(o)),M=Math.sin(g),v=Math.cos(g),w=Math.sin(m),y=Math.cos(m);let R,b,z,q,S,_,k,A,E,x,N=1e3,P=d;do{if(k=Math.sin(P),A=Math.cos(P),z=Math.sqrt(y*k*(y*k)+(v*w-M*y*A)*(v*w-M*y*A)),0===z)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;S=M*w+v*y*A,_=Math.atan2(z,S),E=v*y*k/z,b=1-E*E,q=S-2*M*w/b,isNaN(q)&&(q=0),x=h/16*b*(4+h*(4-3*b)),R=P,P=d+(1-x)*h*E*(_+x*z*(q+x*S*(2*q*q-1)))}while(Math.abs(P-R)>1e-12&&--N>0);if(0===N){const t=f,n=Math.acos(Math.sin(a)*Math.sin(o)+Math.cos(a)*Math.cos(o)*Math.cos(r-s))*t,i=r-s,l=Math.sin(i)*Math.cos(o),u=Math.cos(a)*Math.sin(o)-Math.sin(a)*Math.cos(o)*Math.cos(i),h=Math.atan2(l,u);return e.azimuth=h/c.eh,e.distance=n,e.reverseAzimuth=void 0,e}const Z=b*(l*l-u*u)/(u*u),C=Z/1024*(256+Z*(Z*(74-47*Z)-128)),D=u*(1+Z/16384*(4096+Z*(Z*(320-175*Z)-768)))*(_-C*z*(q+C/4*(S*(2*q*q-1)-C/6*q*(4*z*z-3)*(4*q*q-3)))),G=Math.atan2(y*Math.sin(P),v*w-M*y*Math.cos(P)),I=Math.atan2(v*Math.sin(P),v*w*Math.cos(P)-M*y);return e.azimuth=G/c.eh,e.distance=D,e.reverseAzimuth=I/c.eh,e}function z(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"meters";if(!e||!t)throw new i.default("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!t.spatialReference)throw new i.default("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!(0,h.aI)(e.spatialReference,t.spatialReference))throw new i.default("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:a}=e;if(!m(a))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===t.x&&e.y===t.y)return new y(0,0,0);const r=new y;return b(r,[e.x,e.y],[t.x,t.y],a),r.distance=(0,s.oU)(r.distance,"meters",n),r.azimuth=d(r.azimuth),r.reverseAzimuth=d(r.reverseAzimuth),r}function q(e,t,n){if(!e||null==t||null==n)throw new i.default("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(n<0||n>360)throw new i.default("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0\xb0 to 360\xb0 degrees");if(!e.spatialReference)throw new i.default("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:s}=e;if(!m(s))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");const a=[0,0];return R(a,[e.x,e.y],n,t,s),new r.default({x:a[0],y:a[1],spatialReference:s})}function S(e){return m(e)?e:(0,h.K8)(e)?u.default.WGS84:null}},23758:(e,t,n)=>{n.d(t,{W:()=>o,e:()=>r});var i=n(18690),s=n(31633),a=n(97153);function r(e){if(null==e)return null;if((0,a.Q)(e))return o(e);const t=e.tileInfo;if(null==t)return null;const n=t.lods?.at(-1);return null==n?null:n.resolution*(0,s.GA)(t.spatialReference)}function o(e){if(null==e)return null;const t=e.layers.items.map(l).filter(i.Ru);return(0,i.jk)(t)??null}function l(e){return e&&"tileInfo"in e?r(e):null}},59177:(e,t,n)=>{n.r(t),n.d(t,{default:()=>f});var i=n(35143),s=n(69539),a=n(54901),r=n(68134),o=n(46053),l=(n(81806),n(76460),n(47249),n(85842)),u=n(84174),c=n(23758);let h=class extends u.default{constructor(e){super(e),this.type="query",this.color=new s.default("#db334a"),this.viewVisualizationEnabled=!0,this.source=null,this.numSamplesForPreview=50,this.numSamplesPerChunk=500}get minDemResolution(){return(0,c.e)(this.source)}get available(){const e=this.source;return!!e&&(null==e.visible||e.visible)&&(null==e.layers||e.layers.some((e=>e.visible)))}queryElevation(e,t){if(!this.source)throw new Error("No source configured for the elevation profile line");return this.source.queryElevation(e,t)}attach(e){return(0,a.vE)([super.attach(e),(0,r.watch)((()=>this.source),(()=>this._onChange()),r.sync)])}};(0,i._)([(0,o.MZ)({type:s.default,nonNullable:!0})],h.prototype,"color",void 0),(0,i._)([(0,o.MZ)()],h.prototype,"viewVisualizationEnabled",void 0),(0,i._)([(0,o.MZ)()],h.prototype,"source",void 0),(0,i._)([(0,o.MZ)({readOnly:!0})],h.prototype,"minDemResolution",null),(0,i._)([(0,o.MZ)()],h.prototype,"available",null),h=(0,i._)([(0,l.$)("esri.widgets.ElevationProfile.ElevationProfileLineQuery")],h);const f=h}}]);
//# sourceMappingURL=13481.be90528a.chunk.js.map