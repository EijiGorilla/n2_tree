"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[29310,30211],{29310:(e,t,a)=>{a.r(t),a.d(t,{createRasterLayerAdapter:()=>R,getDefaultBandCombination:()=>M,getSupportedRendererInfo:()=>x,processRasterRendererParameters:()=>F});var r=a(50076),s=a(78937),n=a(35143),i=a(46053),o=(a(81806),a(76460),a(47249),a(85842)),l=a(19247),u=a(86866),c=a(46570),m=a(49304),d=a(53521);let p=class extends m.A{constructor(){super(...arguments),this.type="raster-layer-adapter",this._statsCache=new d.q(20)}get serviceRasterInfo(){return this.rasterInfo}async updateRasterInfo(e){this.rasterInfo=await this.generateRasterInfo(e),this.rasterFunction=e?.rasterFunction}async updateRasterInfoWithEstimatedStats(e,t){const a=await this.estimateStatisticsHistograms(t);a?.statistics&&(e.statistics=a.statistics),a?.histograms&&(e.histograms=a.histograms)}};(0,n._)([(0,i.MZ)()],p.prototype,"layer",void 0),(0,n._)([(0,i.MZ)()],p.prototype,"serviceRasterInfo",null),(0,n._)([(0,i.MZ)()],p.prototype,"rasterInfo",void 0),(0,n._)([(0,i.MZ)()],p.prototype,"rasterFunction",void 0),(0,n._)([(0,i.MZ)({readOnly:!0})],p.prototype,"type",void 0),(0,n._)([(0,i.MZ)()],p.prototype,"version",void 0),p=(0,n._)([(0,o.$)("esri.smartMapping.raster.support.adapters.RasterLayerAdapter")],p);const h=p;let f=class extends h{generateRasterInfo(e){const t=e?.rasterFunction;try{return this.layer.generateRasterInfo(t,{signal:e?.signal})}catch{return Promise.resolve(this.layer.serviceRasterInfo)}}async estimateStatisticsHistograms(e){const{layer:t}=this,a=t.mosaicRule?.multidimensionalDefinition?.[0]?.variableName??"",r=`${e?.rasterFunction?.functionName??"default"}${a}`,s=this._statsCache.get(r);if(s)return s;let{width:n,height:i,pixelSize:o}=t.rasterInfo,m=1;for(;n>2e3||i>2e3;)n/=2,i/=2,m*=2;const d=e?.rasterFunction??t.rasterFunction,{fullExtent:p,mosaicRule:h}=t;o=new l.default(o.x*m,o.y*m,p.spatialReference);const f=new c.default({geometry:p,pixelSize:o,renderingRule:d,mosaicRule:h});let y;if(t.capabilities.operations.supportsComputeStatisticsHistograms)y=await t.computeStatisticsHistograms(f,e);else{const{histograms:a}=await t.computeHistograms(f,e);y={statistics:(0,u.Pg)(a),histograms:a}}return y&&this._statsCache.put(r,y),y}supportsMultidirectionalHillshade(){return this.layer.version>=10.81}load(e){return this.addResolvingPromise(this.layer.load(e).then((()=>{this.generateRasterInfo({rasterFunction:this.rasterFunction,signal:e?.signal}).then((e=>this.rasterInfo=e))}))),Promise.resolve(this)}};(0,n._)([(0,i.MZ)()],f.prototype,"layer",void 0),f=(0,n._)([(0,o.$)("esri.smartMapping.raster.support.adapters.ImageryLayerAdapter")],f);const y=f;var g=a(76797);let b=class extends h{async generateRasterInfo(e){const{layer:t}=this,a=e?.rasterFunction;if("imagery-tile"===t.type&&a)try{return await t.generateRasterInfo(a,{signal:e?.signal})}catch{return t.serviceRasterInfo}return this.rasterInfo}async estimateStatisticsHistograms(e){const{layer:t}=this,a=t.multidimensionalDefinition?.[0]?.variableName??"",s=`${t.rasterFunction?.functionName??"default"}${a}`,n=this._statsCache.get(s);if(n)return n;const{raster:i}=t,{extent:o,width:l,height:c}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;const{pyramidScalingFactor:a,maximumPyramidLevel:r}=e.storageInfo;let{extent:s,width:n,height:i,pixelSize:o}=e,l=Math.max(0,Math.ceil(Math.log(Math.max(n,i)/t)/Math.log(a))-1),u=0,c=0;if(l<=r){const e=a**l;n=Math.floor(n/e),i=Math.floor(i/e)}else l=0,n=Math.min(n,t),i=Math.min(i,t),u=Math.max(Math.floor(n/2-500),0),c=Math.max(Math.floor(i/2-500),0),s=new g.default({xmin:s.xmin+u*o.x,xmax:Math.min(s.xmax,s.xmin+u*o.x*t),ymin:s.ymin+c*o.y,ymax:Math.min(s.ymax,s.ymin+c*o.y*t)});return{extent:s,width:n,height:i,origin:{x:u,y:c}}}(i.rasterInfo),{pixelBlock:m}=await t.fetchPixels(o,l,c,e);if(null==m)throw new r.default("raster-layer-adapter","Unable to estimate histograms");const d=(0,u.f4)(m);return d&&this._statsCache.put(s,d),d}supportsMultidirectionalHillshade(){return!0}load(e){return this.addResolvingPromise(this.layer.load(e).then((()=>this.rasterInfo=this.layer.raster.rasterInfo))),Promise.resolve(this)}};(0,n._)([(0,i.MZ)()],b.prototype,"layer",void 0),b=(0,n._)([(0,o.$)("esri.smartMapping.raster.support.adapters.ImageryTileLayerAdapter")],b);const w={imagery:{adapter:y,label:"ImageryLayer"},"imagery-tile":{adapter:b,label:"ImageryTileLayer"},wcs:{adapter:b,label:"WCSLayer"}},v={"raster-stretch":"raster-stretch","unique-value":"raster-unique-value","raster-rgb":"raster-rgb","class-breaks":"raster-class-breaks","raster-colormap":"raster-colormap","raster-shaded-relief":"raster-shaded-relief","vector-field":"raster-vector-field",flow:"raster-flow"},I=Object.keys(w).map((e=>w[e].label));function R(e){if("raster-layer-adapter"===e.type)return e;const t=w[e.type]?.adapter;return null==t?null:new t({layer:e})}async function x(e){const t=R((e=await F(e)).layer),a=await t.generateRasterInfo(e),r=(0,s.fp)(a,!0).map((e=>v[e])),n=t.layer,i="imagery-tile"===n.type?(0,s.Mm)(n.raster):void 0,o="wcs"!==n.type?n.presetRenderers:void 0,l=(0,s.I8)({variableName:e.variableName,rasterFunctionName:e.rasterFunction?.functionName,presetRenderers:o}),u=l?.renderer??(0,s.PD)(a,{rasterFunctionColorRamp:i,variableName:e.variableName}),{bandCount:c}=a;return c>1&&r.push("raster-rgb"),!r.includes("raster-class-breaks")&&1===c&&+t.layer?.version>=10.3&&r.push("raster-class-breaks"),{supportedTypes:r,defaultRenderer:u}}async function M(e){const t=R((e=await F(e)).layer),a=await t.generateRasterInfo(e),{layer:r}=t;if("wcs"!==r.type&&r.presetRenderers?.length){const t=(0,s.I8)({variableName:e.variableName,rasterFunctionName:e.rasterFunction?.functionName,presetRenderers:r.presetRenderers});if(t?.bandIds?.length)return t.bandIds}return(0,s.ci)(a)}async function F(e){const{layer:t}=e;if(!t)throw new r.default("raster-renderer-creator:missing-parameters","'layer' parameter is required");const a=R(t);if(null==a)throw new r.default("raster-renderer-creator:invalid-parameters","'layer' must be one of these types: "+I.join(", "));await a.load();const s=e.rasterFunction??e.renderingRule??t.rasterFunction;return await a.updateRasterInfo({rasterFunction:s,signal:e.signal}),{...e,layer:a,rasterFunction:s}}},30211:(e,t,a)=>{a.r(t),a.d(t,{createRenderer:()=>l});var r=a(50076),s=a(50265),n=a(78937),i=a(29310);function o(e){const{rasterInfo:t,layer:a}=e,r=t.multidimensionalInfo?"imagery"===a.type?a.mosaicRule?.multidimensionalDefinition?.[0]?.variableName:a.multidimensionalDefinition?.[0]?.variableName:"";return(0,n.m7)(t,r)}async function l(e){const t=o((e=await async function(e){const t=o((e=await(0,i.processRasterRendererParameters)(e)).layer);if(t.bandCount>1)throw new r.default("raster-class-breaks-renderer:not-supported","Multiband raster is not supported");const{attributeTable:a}=t;e.field||(e.field=(0,n.VI)(a,"value")?.name??"value");const{colors:s,numClasses:l}=e;if(s&&l&&s.length!==l)throw new r.default("raster-class-breaks-renderer:not-supported","The size of the `colors` parameter does not match 'numClasses'");return e.classificationMethod||(e.classificationMethod="natural-breaks"),e}(e)).layer).clone(),a=t.attributeTable?.fields.find((t=>t.name.toLowerCase()===e.field?.toLowerCase()));if(!a&&!t.histograms?.length&&(await e.layer.updateRasterInfoWithEstimatedStats(t,{rasterFunction:e.rasterFunction,signal:e.signal}),!t.histograms?.length))throw new r.default("raster-class-breaks-renderer:not-supported","Histograms or raster attribute table is required on the source raster. Unable to estimate histograms");const l=(0,n.Ix)(t,e);if(null==l)throw new r.default("raster-class-breaks-renderer:not-supported","Class breaks renderer is not supported on this data");const u={minValue:l.minValue,maxValue:l.classBreakInfos[l.classBreakInfos.length-1].maxValue,normalizationTotal:null,classBreakInfos:l.classBreakInfos.map((e=>{const t=function(e,t){return(0,s.ZV)(e,{maximumFractionDigits:3})+" - "+(0,s.ZV)(t,{maximumFractionDigits:3})}(e.minValue,e.maxValue);return e.label=t,{minValue:e.minValue,maxValue:e.maxValue,label:t}}))};return{renderer:l,classBreaksResult:u}}}}]);
//# sourceMappingURL=30211.70ba1503.chunk.js.map