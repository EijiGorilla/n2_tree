"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[16564,20033],{16564:(o,e,t)=>{t.r(e),t.d(e,{default:()=>_});var s=t(35143),r=t(19276),i=t(42553),l=t(53084),n=t(46053),a=t(40565),p=t(85842),c=t(69539),u=t(69098);t(81806),t(47249);let h=class extends(u.A.ClonableMixin(i.A)){constructor(){super(...arguments),this.color=c.default.fromArray([0,0,0,0]),this.value=0,this.enabled=!0,this.label="",this.colorLocked=!1}};(0,s._)([(0,n.MZ)({type:c.default,json:{type:[a.jz],write:{enabled:!0,isRequired:!0}}})],h.prototype,"color",void 0),(0,s._)([(0,n.MZ)({type:Number,json:{write:{enabled:!0,isRequired:!0}}})],h.prototype,"value",void 0),(0,s._)([(0,n.MZ)({type:Boolean,json:{default:!0,write:!0}})],h.prototype,"enabled",void 0),(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],h.prototype,"label",void 0),(0,s._)([(0,n.MZ)({type:Boolean,json:{default:!1,write:!0}})],h.prototype,"colorLocked",void 0),h=(0,s._)([(0,p.$)("esri.layers.voxel.VoxelIsosurface")],h);const d=h;var y=t(20033);let f=class extends(u.A.ClonableMixin(i.A)){constructor(){super(...arguments),this.color=c.default.fromArray([0,0,0,0]),this.value=0,this.enabled=!0,this.label=""}};(0,s._)([(0,n.MZ)({type:c.default,json:{type:[a.jz],write:{enabled:!0,isRequired:!0}}})],f.prototype,"color",void 0),(0,s._)([(0,n.MZ)({type:a.jz,json:{write:{enabled:!0,isRequired:!0}}})],f.prototype,"value",void 0),(0,s._)([(0,n.MZ)({type:Boolean,json:{default:!0,write:!0}})],f.prototype,"enabled",void 0),(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],f.prototype,"label",void 0),f=(0,s._)([(0,p.$)("esri.layers.voxel.VoxelUniqueValue")],f);const b=f;var v;let M=v=class extends i.A{constructor(o){super(o),this.variableId=0,this.label="",this.transferFunction=null,this.uniqueValues=null,this.isosurfaces=null,this.uniqueValues=new(r.default.ofType(b)),this.isosurfaces=new(r.default.ofType(d))}clone(){return new v({variableId:this.variableId,label:this.label,transferFunction:(0,l.clone)(this.transferFunction),uniqueValues:(0,l.clone)(this.uniqueValues),isosurfaces:(0,l.clone)(this.isosurfaces)})}};(0,s._)([(0,n.MZ)({type:a.jz,json:{write:{enabled:!0,isRequired:!0}}})],M.prototype,"variableId",void 0),(0,s._)([(0,n.MZ)({type:String,json:{write:!0}})],M.prototype,"label",void 0),(0,s._)([(0,n.MZ)({type:y.default,json:{write:{enabled:!0,overridePolicy(){return{enabled:!this.uniqueValues||this.uniqueValues.length<1}}}}})],M.prototype,"transferFunction",void 0),(0,s._)([(0,n.MZ)({type:r.default.ofType(b),json:{write:{enabled:!0,overridePolicy(){return{enabled:!!this.uniqueValues&&this.uniqueValues.length>0}}}}})],M.prototype,"uniqueValues",void 0),(0,s._)([(0,n.MZ)({type:r.default.ofType(d),json:{write:{enabled:!0,overridePolicy(){const o=!this.uniqueValues||this.uniqueValues.length<1,e=!!this.isosurfaces&&this.isosurfaces.length>0;return{enabled:o&&e}}}}})],M.prototype,"isosurfaces",void 0),M=v=(0,s._)([(0,p.$)("esri.layers.voxel.VoxelVariableStyle")],M);const _=M},20033:(o,e,t)=>{t.r(e),t.d(e,{default:()=>S});var s=t(35143),r=t(69539),i=t(69098),l=t(19276),n=t(3975),a=t(42553),p=t(15941),c=t(46053),u=(t(81806),t(76460),t(47249),t(85842)),h=t(40565);let d=class extends(i.A.ClonableMixin(a.A)){constructor(){super(...arguments),this.color=null,this.position=0}};(0,s._)([(0,c.MZ)({type:r.default,json:{type:[h.jz],write:{enabled:!0,isRequired:!0}}})],d.prototype,"color",void 0),(0,s._)([(0,c.MZ)({type:Number,json:{write:{enabled:!0,isRequired:!0}}})],d.prototype,"position",void 0),d=(0,s._)([(0,u.$)("esri.layers.voxel.VoxelColorStop")],d);const y=d;let f=class extends(i.A.ClonableMixin(a.A)){constructor(){super(...arguments),this.opacity=1,this.position=0}};(0,s._)([(0,c.MZ)({type:Number,json:{name:"alpha",write:{enabled:!0,isRequired:!0}}})],f.prototype,"opacity",void 0),(0,s._)([(0,c.MZ)({type:Number,json:{write:{enabled:!0,isRequired:!0}}})],f.prototype,"position",void 0),f=(0,s._)([(0,u.$)("esri.layers.voxel.VoxelOpacityStop")],f);const b=f;let v=class extends(i.A.ClonableMixin(a.A)){constructor(){super(...arguments),this.enabled=!1,this.range=null}};(0,s._)([(0,c.MZ)({type:Boolean,json:{default:!1,write:!0}})],v.prototype,"enabled",void 0),(0,s._)([(0,c.MZ)({type:[Number],json:{write:{isRequired:!0}}})],v.prototype,"range",void 0),v=(0,s._)([(0,u.$)("esri.layers.voxel.VoxelRangeFilter")],v);const M=v;var _,g;(g=_||(_={}))[g.Color=1]="Color",g[g.Alpha=2]="Alpha",g[g.Both=3]="Both";let w=class extends(i.A.ClonableMixin(a.A)){constructor(o){super(o),this.interpolation=null,this.stretchRange=null,this.rangeFilter=null,this._colorMapSize=256,this.colorStops=new(l.default.ofType(y)),this.opacityStops=new(l.default.ofType(b))}set colorStops(o){this._set("colorStops",(0,n.V)(o,this._get("colorStops"),l.default.ofType(y)))}set opacityStops(o){this._set("opacityStops",(0,n.V)(o,this._get("opacityStops"),l.default.ofType(b)))}getPreviousNext(o,e,t){let s=o;for(;--s>0&&e[s].type!==t&&e[s].type!==_.Both;);let r=o;const i=e.length;for(;++r<i&&e[r].type!==t&&e[r].type!==_.Both;);return[s,r]}get rasterizedTransferFunction(){const o=[];if(this.colorStops.length<2)return o;const e=[],t=[];for(const r of this.colorStops){if(!r.color)return o;t.push({color:{r:r.color.r,g:r.color.g,b:r.color.b,a:Math.round(255*(1-r.color.a))},position:r.position,type:_.Color})}if(0===this.opacityStops.length)for(const r of t)e.push({color:r.color,position:r.position});else{for(const e of this.opacityStops){const o=(0,p.qE)(e.position,0,1),s=Math.round(255*(0,p.qE)(1-e.opacity,0,1));let r=!1;for(const e of t)if(e.type===_.Color&&Math.abs(e.position-o)<1e-5){e.color.a=s,e.type=_.Both,r=!0;break}r||t.push({color:{r:0,g:0,b:0,a:s},position:e.position,type:_.Alpha})}t.sort(((o,e)=>o.position<e.position?-1:1));const o=t.length;for(let e=0;e<o;++e){const s=t[e];if(s.type!==_.Both)if(s.type===_.Color){const[r,i]=this.getPreviousNext(e,t,_.Alpha);if(-1!==r&&i!==o){const o=(s.position-t[r].position)/(t[i].position-t[r].position);s.color.a=Math.round((0,p.Cc)(t[r].color.a,t[i].color.a,o))}else s.color.a=-1!==r?t[r].color.a:t[i].color.a}else{const[r,i]=this.getPreviousNext(e,t,_.Color);if(-1!==r&&i!==o){const o=(s.position-t[r].position)/(t[i].position-t[r].position),e=t[r].color,l=t[i].color;j.forEach((t=>{s.color[t]=Math.round((0,p.Cc)(e[t],l[t],o))}))}else-1!==r?j.forEach((o=>{s.color[o]=t[r].color[o]})):j.forEach((o=>{s.color[o]=t[i].color[o]}))}}for(const s of t)e.push({color:s.color,position:s.position})}e[0].position=0,e[e.length-1].position=1;let s=0,i=1;for(let l=0;l<this._colorMapSize;++l){const t=l/this._colorMapSize;for(;t>e[i].position;)s=i++;const n=(t-e[s].position)/(e[i].position-e[s].position),a=e[s].color,c=e[i].color,u=new r.default;j.forEach((o=>{u[o]=Math.round((0,p.Cc)(a[o],c[o],n))})),u.a=(0,p.qE)(1-(0,p.Cc)(a.a,c.a,n)/255,0,1),o.push(u)}return o}getColorForContinuousDataValue(o,e){const t=this.rasterizedTransferFunction;if(this.colorStops.length<2||!Array.isArray(this.stretchRange)||this.stretchRange.length<2||t.length<256)return null;let s=this.stretchRange[0],r=this.stretchRange[1];if(s>r){const o=s;s=r,r=o}o=(0,p.qE)(o,s,r);const i=t[Math.round((o-s)/(r-s)*(this._colorMapSize-1))].clone();return e||(i.a=1),i}};(0,s._)([(0,c.MZ)({type:["linear","nearest"],json:{write:!0}})],w.prototype,"interpolation",void 0),(0,s._)([(0,c.MZ)({type:[Number],json:{write:{enabled:!0,isRequired:!0}}})],w.prototype,"stretchRange",void 0),(0,s._)([(0,c.MZ)({type:l.default.ofType(y),json:{write:{enabled:!0,overridePolicy(){return{enabled:!!this.colorStops&&this.colorStops.length>0}}}}})],w.prototype,"colorStops",null),(0,s._)([(0,c.MZ)({type:l.default.ofType(b),json:{read:{source:"alphaStops"},write:{enabled:!0,target:"alphaStops",overridePolicy(){return{enabled:!!this.opacityStops&&this.opacityStops.length>0}}}}})],w.prototype,"opacityStops",null),(0,s._)([(0,c.MZ)({type:M,json:{write:!0}})],w.prototype,"rangeFilter",void 0),(0,s._)([(0,c.MZ)({type:[r.default],clonable:!1,json:{read:!1}})],w.prototype,"rasterizedTransferFunction",null),w=(0,s._)([(0,u.$)("esri.layers.voxel.VoxelTransferFunctionStyle")],w);const S=w,j=["r","g","b"]}}]);
//# sourceMappingURL=16564.9ca266db.chunk.js.map