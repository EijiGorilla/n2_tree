"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[2267,7137,24648,29518,51899,57505,73265,79886],{7137:(e,t,n)=>{n.r(t),n.d(t,{InverseGeodeticSolverResult:()=>w,directGeodeticSolver:()=>R,geodesicAreas:()=>M,geodesicCompatibleSpatialReference:()=>S,geodesicDensify:()=>y,geodesicDistance:()=>z,geodesicLengths:()=>m,inverseGeodeticSolver:()=>b,isSupported:()=>v,pointFromDistance:()=>U});var i=n(50076),r=n(31633),a=n(40565),s=n(19247),o=n(65215),l=n(23701),c=n(13312),u=n(63885),h=n(80963);function f(e){if(!e)return null;const t=e.wkid;if(t)return u.uw[t];const n=e.wkt2??e.wkt;return n?function(e){const t=u._f.exec(e);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),r=parseFloat(n[2]);return isNaN(i)||isNaN(r)?null:{a:i,f:0===r?0:1/r}}(n):null}function p(e){const t=f(e);if(function(e){return null!=e&&"b"in e&&"eSq"in e&&"radius"in e}(t))return t;const n=t.a*(1-t.f);return Object.assign(t,{b:n,eSq:1-(n/t.a)**2,radius:(2*t.a+n)/3,densificationRatio:1e4/((2*t.a+n)/3)})}function d(e){return null!=e&&e<0?e+360:e}function g(e,t,n){const{a:i,eSq:r}=p(n),a=Math.sqrt(r),s=Math.sin(t[1]*u.eh),o=i*t[0]*u.eh;let l;return l=r>0?i*((1-r)*(s/(1-r*(s*s))-1/(2*a)*Math.log((1-a*s)/(1+a*s))))*.5:i*s,e[0]=o,e[1]=l,e}function v(e){return(0,h.EA)(e)&&!!f(e)}function M(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"square-meters";if(e.some((e=>!v(e.spatialReference))))throw new i.default("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const t=e[i],r=t.spatialReference,{radius:a,densificationRatio:s}=p(r),o=a*s;n.push(y(t,o))}const a=[],s=[0,0],o=[0,0];for(let i=0;i<n.length;i++){const{rings:e,spatialReference:l}=n[i];let c=0;for(let t=0;t<e.length;t++){const n=e[t];g(s,n[0],l),g(o,n[n.length-1],l);let i=o[0]*s[1]-s[0]*o[1];for(let e=0;e<n.length-1;e++)g(s,n[e+1],l),g(o,n[e],l),i+=o[0]*s[1]-s[0]*o[1];c+=i}c=(0,r.oU)(c,"square-meters",t),a.push(c/-2)}return a}function m(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"meters";if(!e)throw new i.default("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some((e=>!v(e.spatialReference))))throw new i.default("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const a=e[i],{spatialReference:s}=a,o="polyline"===a.type?a.paths:a.rings;let l=0;for(let e=0;e<o.length;e++){const t=o[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],r=t[e][0],a=t[e-1][1],o=t[e][1];if(a!==o||i!==r){const e=new w;b(e,[i,a],[r,o],s),n+=e.distance}}l+=n}l=(0,r.oU)(l,"meters",t),n.push(l)}return n}function y(e,t){if("polyline"!==e.type&&"polygon"!==e.type)throw new i.default("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=e;if(!v(n))throw new i.default("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const r="polyline"===e.type?e.paths:e.rings,s=[],u=[0,0],h=new w;for(const i of r){const e=[];s.push(e),e.push([i[0][0],i[0][1]]);let r,a,o=i[0][0],l=i[0][1];for(let s=0;s<i.length-1;s++){if(r=i[s+1][0],a=i[s+1][1],o===r&&l===a)continue;const c=[o,l];b(h,[o,l],[r,a],n);const{azimuth:f,distance:p}=h,d=p/t;if(d>1){for(let i=1;i<=d-1;i++)R(u,c,f,i*t,n),e.push(u.slice());R(u,c,f,(p+Math.floor(d-1)*t)/2,n),e.push(u.slice())}R(u,c,f,p,n),e.push(u.slice()),o=u[0],l=u[1]}}const f=(0,a.PZ)(c.default,n);return"polyline"===e.type?new l.default({paths:s,spatialReference:f}):new o.default({rings:s,spatialReference:f})}class w{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.distance=e,this.azimuth=t,this.reverseAzimuth=n}}function R(e,t,n,i,r){const a=t[0],s=t[1],o=a*u.eh,l=s*u.eh,c=(n??0)*u.eh,{a:h,b:f,f:d}=p(r),g=Math.sin(c),v=Math.cos(c),M=(1-d)*Math.tan(l),m=1/Math.sqrt(1+M*M),y=M*m,w=Math.atan2(M,v),R=m*g,b=R*R,z=1-b,U=z*(h*h-f*f)/(f*f),S=1+U/16384*(4096+U*(U*(320-175*U)-768)),_=U/1024*(256+U*(U*(74-47*U)-128));let q,x,Z,A=i/(f*S),k=2*Math.PI;for(;Math.abs(A-k)>1e-12;)Z=Math.cos(2*w+A),q=Math.sin(A),x=Math.cos(A),k=A,A=i/(f*S)+_*q*(Z+_/4*(x*(2*Z*Z-1)-_/6*Z*(4*q*q-3)*(4*Z*Z-3)));const I=y*q-m*x*v,W=Math.atan2(y*x+m*q*v,(1-d)*Math.sqrt(b+I*I)),B=d/16*z*(4+d*(4-3*z)),F=Math.atan2(q*g,m*x-y*q*v)-(1-B)*d*R*(A+B*q*(Z+B*x*(2*Z*Z-1)));return e[0]=(o+F)/u.eh,e[1]=W/u.eh,e}function b(e,t,n,i){const r=t[0]*u.eh,a=t[1]*u.eh,s=n[0]*u.eh,o=n[1]*u.eh,{a:l,b:c,f:h,radius:f}=p(i),d=s-r,g=Math.atan((1-h)*Math.tan(a)),v=Math.atan((1-h)*Math.tan(o)),M=Math.sin(g),m=Math.cos(g),y=Math.sin(v),w=Math.cos(v);let R,b,z,U,S,_,q,x,Z,A,k=1e3,I=d;do{if(q=Math.sin(I),x=Math.cos(I),z=Math.sqrt(w*q*(w*q)+(m*y-M*w*x)*(m*y-M*w*x)),0===z)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;S=M*y+m*w*x,_=Math.atan2(z,S),Z=m*w*q/z,b=1-Z*Z,U=S-2*M*y/b,isNaN(U)&&(U=0),A=h/16*b*(4+h*(4-3*b)),R=I,I=d+(1-A)*h*Z*(_+A*z*(U+A*S*(2*U*U-1)))}while(Math.abs(I-R)>1e-12&&--k>0);if(0===k){const t=f,n=Math.acos(Math.sin(a)*Math.sin(o)+Math.cos(a)*Math.cos(o)*Math.cos(s-r))*t,i=s-r,l=Math.sin(i)*Math.cos(o),c=Math.cos(a)*Math.sin(o)-Math.sin(a)*Math.cos(o)*Math.cos(i),h=Math.atan2(l,c);return e.azimuth=h/u.eh,e.distance=n,e.reverseAzimuth=void 0,e}const W=b*(l*l-c*c)/(c*c),B=W/1024*(256+W*(W*(74-47*W)-128)),F=c*(1+W/16384*(4096+W*(W*(320-175*W)-768)))*(_-B*z*(U+B/4*(S*(2*U*U-1)-B/6*U*(4*z*z-3)*(4*U*U-3)))),N=Math.atan2(w*Math.sin(I),m*y-M*w*Math.cos(I)),T=Math.atan2(m*Math.sin(I),m*y*Math.cos(I)-M*w);return e.azimuth=N/u.eh,e.distance=F,e.reverseAzimuth=T/u.eh,e}function z(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"meters";if(!e||!t)throw new i.default("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!t.spatialReference)throw new i.default("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!(0,h.aI)(e.spatialReference,t.spatialReference))throw new i.default("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:a}=e;if(!v(a))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===t.x&&e.y===t.y)return new w(0,0,0);const s=new w;return b(s,[e.x,e.y],[t.x,t.y],a),s.distance=(0,r.oU)(s.distance,"meters",n),s.azimuth=d(s.azimuth),s.reverseAzimuth=d(s.reverseAzimuth),s}function U(e,t,n){if(!e||null==t||null==n)throw new i.default("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(n<0||n>360)throw new i.default("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0\xb0 to 360\xb0 degrees");if(!e.spatialReference)throw new i.default("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:r}=e;if(!v(r))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");const a=[0,0];return R(a,[e.x,e.y],n,t,r),new s.default({x:a[0],y:a[1],spatialReference:r})}function S(e){return v(e)?e:(0,h.K8)(e)?c.default.WGS84:null}},14487:(e,t,n)=>{n.d(t,{F:()=>a});n(9624);var i=n(13312),r=n(64232);function a(e,t,n,i,a){return!(null==t||null==i||e.length<2)&&(s.x=e[0],s.y=e[1],s.z=e[2],s.spatialReference=t,(0,r.g)(s,n,i,a))}const s=(0,n(18117).T)(0,0,0,i.default.WGS84)},18117:(e,t,n)=>{function i(e,t,n,i){return{x:e,y:t,z:n,hasZ:null!=n,hasM:!1,spatialReference:i,type:"point"}}function r(e,t,n,i,r){e.x=t,e.y=n,e.z=i,e.hasZ=null!=i,e.spatialReference=r}n.d(t,{J:()=>r,T:()=>i})},24648:(e,t,n)=>{n.d(t,{IV:()=>g,LF:()=>r,T9:()=>u,Wq:()=>o,d_:()=>a,g2:()=>f,gT:()=>s,hs:()=>h,iT:()=>d,kM:()=>l,l3:()=>c,n0:()=>v,r7:()=>p});var i=n(31633);function r(e){return{value:e}}function a(e,t){return{type:(0,i.t$)(t),value:e,unit:t}}function s(e,t){return{type:(0,i.t$)(t),value:e,unit:t}}function o(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"arithmetic";return{type:(0,i.t$)(t),value:e,unit:t,rotationType:n}}function l(e,t){const n=c(e,t);return"angle"===e.type?o(n,t,e.rotationType):function(e,t){return{type:(0,i.t$)(t),value:e,unit:t}}(n,t)}function c(e,t){return(0,i.oU)(e.value,e.unit,t)}function u(e,t){return null==e?t:null==t||e.value>(0,i.oU)(t.value,t.unit,e.unit)?e:t}function h(e,t){return null==e?null:{...e,value:e.value*t}}function f(e,t,n){if(t===n)return e;switch(n){case"arithmetic":case"geographic":return 90-e}}const p=a(0,"meters"),d=s(0,"square-meters"),g=(o(0,"radians"),o(0,"degrees")),v=o(0,"degrees","geographic")},64232:(e,t,n)=>{n.d(t,{W:()=>o,g:()=>s});var i=n(9392),r=n(9624),a=n(45308);function s(e,t,n,i){if((0,r.canProjectWithoutEngine)(e.spatialReference,n)){l[0]=e.x,l[1]=e.y;const r=e.z;return l[2]=r??i??0,(0,a.projectBuffer)(l,e.spatialReference,0,t,n,0)}const s=(0,r.tryProjectWithZConversion)(e,n);return!!s&&(t[0]=s?.x,t[1]=s?.y,t[2]=s?.z??i??0,!0)}async function o(e,t,n,i,a){return await(0,r.initializeProjection)(e.spatialReference,n,null,a),s(e,t,n,i)}const l=(0,i.vt)()},73265:(e,t,n)=>{n.r(t),n.d(t,{default:()=>h});var i=n(35143),r=n(91967),a=n(46053),s=(n(81806),n(76460),n(47249),n(85842));let o=class extends r.default{constructor(e){super(e),this.length=null,this.verticalLength=null,this.area=null}};(0,i._)([(0,a.MZ)()],o.prototype,"length",void 0),(0,i._)([(0,a.MZ)()],o.prototype,"verticalLength",void 0),(0,i._)([(0,a.MZ)()],o.prototype,"area",void 0),o=(0,i._)([(0,s.$)("esri.views.interactive.sketch.Units")],o);const l=o;var c=n(89646);let u=class extends r.default{constructor(e){super(e),this.directionMode="relative",this.relativeDirectionIsBilateral=!1}get effectiveDirectionMode(){switch(this.directionMode){case"relative":return this.relativeDirectionIsBilateral?c.rZ.RelativeBilateral:c.rZ.Relative;case"absolute":return c.rZ.Absolute}}get displayUnits(){return this._get("displayUnits")??new l}set displayUnits(e){this._set("displayUnits",e)}get inputUnits(){return this._get("inputUnits")??new l}set inputUnits(e){this._set("inputUnits",e)}};(0,i._)([(0,a.MZ)({type:String,nonNullable:!0})],u.prototype,"directionMode",void 0),(0,i._)([(0,a.MZ)({type:Boolean,nonNullable:!0})],u.prototype,"relativeDirectionIsBilateral",void 0),(0,i._)([(0,a.MZ)()],u.prototype,"effectiveDirectionMode",null),(0,i._)([(0,a.MZ)({type:l,nonNullable:!0})],u.prototype,"displayUnits",null),(0,i._)([(0,a.MZ)({type:l,nonNullable:!0})],u.prototype,"inputUnits",null),u=(0,i._)([(0,s.$)("esri.views.interactive.sketch.SketchValueOptions")],u);const h=u},89646:(e,t,n)=>{n.d(t,{$h:()=>d,Ef:()=>z,IP:()=>v,P1:()=>w,hF:()=>b,jQ:()=>y,rT:()=>R,rZ:()=>i,uR:()=>M});var i,r=n(73582),a=n(24648),s=n(31633),o=n(19555),l=n(72745),c=n(20664),u=n(9392),h=n(14487),f=n(7137),p=n(80963);function d(e,t){if(null==e||null==t)return;const n=g(e,t);return null!=n?(0,a.Wq)(n,"radians","geographic"):void 0}!function(e){e.Absolute="absolute",e.Relative="relative",e.RelativeBilateral="relative-bilateral"}(i||(i={}));const g=(()=>{const e=(0,u.vt)(),t=(0,u.vt)();return(n,i)=>((0,c.i)(e,n.x,n.y,n.z??0),(0,c.i)(t,i.x,i.y,i.z??0),v(e,t,n.spatialReference,i.spatialReference))})(),v=(()=>{const e=(0,l.vt)(),t=(0,u.vt)(),n=(0,u.vt)();return(i,r,a,u)=>{if((0,c.p)(i,r))return;const d=(0,f.geodesicCompatibleSpatialReference)(a),g=(0,f.geodesicCompatibleSpatialReference)(u);if(d&&g&&(0,p.aI)(d,g)&&(0,h.F)(i,a,t,d)&&(0,h.F)(r,u,n,g)){const{azimuth:e}=(0,f.inverseGeodeticSolver)(S,t,n,d);return null!=e?(0,s.oU)(e,"degrees","radians"):void 0}e[0]=r[0]-i[0],e[1]=r[1]-i[1];let v=(0,o.g7)(l.JP,e);return e[0]<0&&(v=_-v),v}})();function M(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:i.Absolute;if(t&&n)switch(r){case i.Absolute:return d(t,n);case i.Relative:return y(m(e,t,n),i.Relative);case i.RelativeBilateral:return y(m(e,t,n),i.RelativeBilateral)}}function m(e,t,n){if(!e||!t||!n)return;const i=g(e,t),r=g(t,n);return null!=i&&null!=r?(0,a.Wq)(r-i,"radians","geographic"):void 0}function y(e,t){if(null!=e)switch(t){case i.Absolute:return w(e);case i.Relative:{const t=b(e);let n=x.normalize(t,0,!0);return-180===n&&(n=180),(0,a.Wq)(n,"degrees","geographic")}case i.RelativeBilateral:{const t=b(e),n=Math.abs(x.normalize(t,0,!0));return(0,a.Wq)(n,"degrees","geographic")}}}function w(e){const t=b(e),n=q.normalize(t,0,!0);return(0,a.Wq)(n,"degrees","geographic")}const R=(()=>{const e=(0,u.vt)();return function(t,n,i,r,o){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"geodesic";(0,c.c)(e,n);const u=b(o);if("geodesic"===l){const a=(0,f.geodesicCompatibleSpatialReference)(i);if(a&&(0,h.F)(e,i,e,a))return(0,f.directGeodeticSolver)(t,e,u,r,a),t[2]=n[2],!!(0,h.F)(t,a,t,i)}const p=(0,a.g2)(u,"geographic","arithmetic"),d=(0,s.oU)(p,"degrees","radians"),g=n[0]+r*Math.cos(d),v=n[1]+r*Math.sin(d),M=n[2];return(0,c.i)(t,g,v,M),!0}})();function b(e){if(null!=e)return(0,a.g2)(U(e),e.rotationType,"geographic")}function z(e){if(null!=e)return(0,a.g2)(U(e),e.rotationType,"arithmetic")}function U(e){return(0,s.oU)(e.value,e.unit,"degrees")}const S=new f.InverseGeodeticSolverResult,_=2*Math.PI,q=r.ie,x=new r.hr(-180,180)}}]);
//# sourceMappingURL=73265.1b97b908.chunk.js.map