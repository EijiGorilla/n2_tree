"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[29310,79760],{29310:(e,t,r)=>{r.r(t),r.d(t,{createRasterLayerAdapter:()=>w,getDefaultBandCombination:()=>M,getSupportedRendererInfo:()=>x,processRasterRendererParameters:()=>F});var a=r(50076),s=r(78937),n=r(35143),i=r(46053),o=(r(81806),r(76460),r(47249),r(85842)),l=r(19247),c=r(86866),u=r(46570),d=r(49304),m=r(53521);let p=class extends d.A{constructor(){super(...arguments),this.type="raster-layer-adapter",this._statsCache=new m.q(20)}get serviceRasterInfo(){return this.rasterInfo}async updateRasterInfo(e){this.rasterInfo=await this.generateRasterInfo(e),this.rasterFunction=e?.rasterFunction}async updateRasterInfoWithEstimatedStats(e,t){const r=await this.estimateStatisticsHistograms(t);r?.statistics&&(e.statistics=r.statistics),r?.histograms&&(e.histograms=r.histograms)}};(0,n._)([(0,i.MZ)()],p.prototype,"layer",void 0),(0,n._)([(0,i.MZ)()],p.prototype,"serviceRasterInfo",null),(0,n._)([(0,i.MZ)()],p.prototype,"rasterInfo",void 0),(0,n._)([(0,i.MZ)()],p.prototype,"rasterFunction",void 0),(0,n._)([(0,i.MZ)({readOnly:!0})],p.prototype,"type",void 0),(0,n._)([(0,i.MZ)()],p.prototype,"version",void 0),p=(0,n._)([(0,o.$)("esri.smartMapping.raster.support.adapters.RasterLayerAdapter")],p);const h=p;let y=class extends h{generateRasterInfo(e){const t=e?.rasterFunction;try{return this.layer.generateRasterInfo(t,{signal:e?.signal})}catch{return Promise.resolve(this.layer.serviceRasterInfo)}}async estimateStatisticsHistograms(e){const{layer:t}=this,r=t.mosaicRule?.multidimensionalDefinition?.[0]?.variableName??"",a=`${e?.rasterFunction?.functionName??"default"}${r}`,s=this._statsCache.get(a);if(s)return s;let{width:n,height:i,pixelSize:o}=t.rasterInfo,d=1;for(;n>2e3||i>2e3;)n/=2,i/=2,d*=2;const m=e?.rasterFunction??t.rasterFunction,{fullExtent:p,mosaicRule:h}=t;o=new l.default(o.x*d,o.y*d,p.spatialReference);const y=new u.default({geometry:p,pixelSize:o,renderingRule:m,mosaicRule:h});let f;if(t.capabilities.operations.supportsComputeStatisticsHistograms)f=await t.computeStatisticsHistograms(y,e);else{const{histograms:r}=await t.computeHistograms(y,e);f={statistics:(0,c.Pg)(r),histograms:r}}return f&&this._statsCache.put(a,f),f}supportsMultidirectionalHillshade(){return this.layer.version>=10.81}load(e){return this.addResolvingPromise(this.layer.load(e).then((()=>{this.generateRasterInfo({rasterFunction:this.rasterFunction,signal:e?.signal}).then((e=>this.rasterInfo=e))}))),Promise.resolve(this)}};(0,n._)([(0,i.MZ)()],y.prototype,"layer",void 0),y=(0,n._)([(0,o.$)("esri.smartMapping.raster.support.adapters.ImageryLayerAdapter")],y);const f=y;var g=r(76797);let I=class extends h{async generateRasterInfo(e){const{layer:t}=this,r=e?.rasterFunction;if("imagery-tile"===t.type&&r)try{return await t.generateRasterInfo(r,{signal:e?.signal})}catch{return t.serviceRasterInfo}return this.rasterInfo}async estimateStatisticsHistograms(e){const{layer:t}=this,r=t.multidimensionalDefinition?.[0]?.variableName??"",s=`${t.rasterFunction?.functionName??"default"}${r}`,n=this._statsCache.get(s);if(n)return n;const{raster:i}=t,{extent:o,width:l,height:u}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;const{pyramidScalingFactor:r,maximumPyramidLevel:a}=e.storageInfo;let{extent:s,width:n,height:i,pixelSize:o}=e,l=Math.max(0,Math.ceil(Math.log(Math.max(n,i)/t)/Math.log(r))-1),c=0,u=0;if(l<=a){const e=r**l;n=Math.floor(n/e),i=Math.floor(i/e)}else l=0,n=Math.min(n,t),i=Math.min(i,t),c=Math.max(Math.floor(n/2-500),0),u=Math.max(Math.floor(i/2-500),0),s=new g.default({xmin:s.xmin+c*o.x,xmax:Math.min(s.xmax,s.xmin+c*o.x*t),ymin:s.ymin+u*o.y,ymax:Math.min(s.ymax,s.ymin+u*o.y*t)});return{extent:s,width:n,height:i,origin:{x:c,y:u}}}(i.rasterInfo),{pixelBlock:d}=await t.fetchPixels(o,l,u,e);if(null==d)throw new a.default("raster-layer-adapter","Unable to estimate histograms");const m=(0,c.f4)(d);return m&&this._statsCache.put(s,m),m}supportsMultidirectionalHillshade(){return!0}load(e){return this.addResolvingPromise(this.layer.load(e).then((()=>this.rasterInfo=this.layer.raster.rasterInfo))),Promise.resolve(this)}};(0,n._)([(0,i.MZ)()],I.prototype,"layer",void 0),I=(0,n._)([(0,o.$)("esri.smartMapping.raster.support.adapters.ImageryTileLayerAdapter")],I);const b={imagery:{adapter:f,label:"ImageryLayer"},"imagery-tile":{adapter:I,label:"ImageryTileLayer"},wcs:{adapter:I,label:"WCSLayer"}},v={"raster-stretch":"raster-stretch","unique-value":"raster-unique-value","raster-rgb":"raster-rgb","class-breaks":"raster-class-breaks","raster-colormap":"raster-colormap","raster-shaded-relief":"raster-shaded-relief","vector-field":"raster-vector-field",flow:"raster-flow"},R=Object.keys(b).map((e=>b[e].label));function w(e){if("raster-layer-adapter"===e.type)return e;const t=b[e.type]?.adapter;return null==t?null:new t({layer:e})}async function x(e){const t=w((e=await F(e)).layer),r=await t.generateRasterInfo(e),a=(0,s.fp)(r,!0).map((e=>v[e])),n=t.layer,i="imagery-tile"===n.type?(0,s.Mm)(n.raster):void 0,o="wcs"!==n.type?n.presetRenderers:void 0,l=(0,s.I8)({variableName:e.variableName,rasterFunctionName:e.rasterFunction?.functionName,presetRenderers:o}),c=l?.renderer??(0,s.PD)(r,{rasterFunctionColorRamp:i,variableName:e.variableName}),{bandCount:u}=r;return u>1&&a.push("raster-rgb"),!a.includes("raster-class-breaks")&&1===u&&+t.layer?.version>=10.3&&a.push("raster-class-breaks"),{supportedTypes:a,defaultRenderer:c}}async function M(e){const t=w((e=await F(e)).layer),r=await t.generateRasterInfo(e),{layer:a}=t;if("wcs"!==a.type&&a.presetRenderers?.length){const t=(0,s.I8)({variableName:e.variableName,rasterFunctionName:e.rasterFunction?.functionName,presetRenderers:a.presetRenderers});if(t?.bandIds?.length)return t.bandIds}return(0,s.ci)(r)}async function F(e){const{layer:t}=e;if(!t)throw new a.default("raster-renderer-creator:missing-parameters","'layer' parameter is required");const r=w(t);if(null==r)throw new a.default("raster-renderer-creator:invalid-parameters","'layer' must be one of these types: "+R.join(", "));await r.load();const s=e.rasterFunction??e.renderingRule??t.rasterFunction;return await r.updateRasterInfo({rasterFunction:s,signal:e.signal}),{...e,layer:r,rasterFunction:s}}},79760:(e,t,r)=>{r.r(t),r.d(t,{createRenderer:()=>i});var a=r(50076),s=r(78937),n=r(29310);async function i(e){const t=(e=await async function(e){e=await(0,n.processRasterRendererParameters)(e);const{serviceRasterInfo:t}=e.layer;if(1===t.bandCount)throw new a.default("raster-rgb-renderer:not-supported","Only multiband image is supported");const{rgbBandIds:r}=e;if(r&&3!==r.length)throw new a.default("raster-rgb-renderer:invalid-parameters","rgb band ids must have exactly three 0-based band indices");if(!r){const r=(0,s.ci)(t);r&&r.length<3&&2===t.bandCount?e.rgbBandIds=[0,1,1]:e.rgbBandIds=r}return e}(e)).layer,{rasterInfo:r}=t,{rgbBandIds:i}=e,o={bandIds:i,stretchType:e.stretchType,includeStatisticsInStretch:e.includeStatisticsInStretch};let l=(0,s.NI)(r,o);if(e.estimateStatistics){e.includeStatisticsInStretch=!0;const a=r.clone();await t.updateRasterInfoWithEstimatedStats(a,{rasterFunction:e.rasterFunction,signal:e.signal}),l=(0,s.NI)(a,o)}return function(e,t){const{gamma:r,useGamma:a,dynamicRangeAdjustment:s}=t;3===r?.length&&(e.gamma=r),null!=a&&(e.useGamma=a),null!=s&&(e.dynamicRangeAdjustment=s)}(l,e),{renderer:l,rgbBandIds:i}}}}]);
//# sourceMappingURL=79760.bc08170a.chunk.js.map