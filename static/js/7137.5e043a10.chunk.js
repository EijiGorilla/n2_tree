"use strict";(self.webpackChunkn2_tree=self.webpackChunkn2_tree||[]).push([[7137,29518,51899],{7137:(e,t,n)=>{n.r(t),n.d(t,{InverseGeodeticSolverResult:()=>y,directGeodeticSolver:()=>R,geodesicAreas:()=>M,geodesicCompatibleSpatialReference:()=>S,geodesicDensify:()=>v,geodesicDistance:()=>z,geodesicLengths:()=>w,inverseGeodeticSolver:()=>b,isSupported:()=>m,pointFromDistance:()=>q});var i=n(50076),s=n(31633),a=n(40565),r=n(19247),o=n(65215),c=n(23701),l=n(13312),h=n(63885),u=n(80963);function f(e){if(!e)return null;const t=e.wkid;if(t)return h.uw[t];const n=e.wkt2??e.wkt;return n?function(e){const t=h._f.exec(e);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),s=parseFloat(n[2]);return isNaN(i)||isNaN(s)?null:{a:i,f:0===s?0:1/s}}(n):null}function p(e){const t=f(e);if(function(e){return null!=e&&"b"in e&&"eSq"in e&&"radius"in e}(t))return t;const n=t.a*(1-t.f);return Object.assign(t,{b:n,eSq:1-(n/t.a)**2,radius:(2*t.a+n)/3,densificationRatio:1e4/((2*t.a+n)/3)})}function d(e){return null!=e&&e<0?e+360:e}function g(e,t,n){const{a:i,eSq:s}=p(n),a=Math.sqrt(s),r=Math.sin(t[1]*h.eh),o=i*t[0]*h.eh;let c;return c=s>0?i*((1-s)*(r/(1-s*(r*r))-1/(2*a)*Math.log((1-a*r)/(1+a*r))))*.5:i*r,e[0]=o,e[1]=c,e}function m(e){return(0,u.EA)(e)&&!!f(e)}function M(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"square-meters";if(e.some((e=>!m(e.spatialReference))))throw new i.default("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const t=e[i],s=t.spatialReference,{radius:a,densificationRatio:r}=p(s),o=a*r;n.push(v(t,o))}const a=[],r=[0,0],o=[0,0];for(let i=0;i<n.length;i++){const{rings:e,spatialReference:c}=n[i];let l=0;for(let t=0;t<e.length;t++){const n=e[t];g(r,n[0],c),g(o,n[n.length-1],c);let i=o[0]*r[1]-r[0]*o[1];for(let e=0;e<n.length-1;e++)g(r,n[e+1],c),g(o,n[e],c),i+=o[0]*r[1]-r[0]*o[1];l+=i}l=(0,s.oU)(l,"square-meters",t),a.push(l/-2)}return a}function w(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"meters";if(!e)throw new i.default("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some((e=>!m(e.spatialReference))))throw new i.default("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const a=e[i],{spatialReference:r}=a,o="polyline"===a.type?a.paths:a.rings;let c=0;for(let e=0;e<o.length;e++){const t=o[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],s=t[e][0],a=t[e-1][1],o=t[e][1];if(a!==o||i!==s){const e=new y;b(e,[i,a],[s,o],r),n+=e.distance}}c+=n}c=(0,s.oU)(c,"meters",t),n.push(c)}return n}function v(e,t){if("polyline"!==e.type&&"polygon"!==e.type)throw new i.default("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=e;if(!m(n))throw new i.default("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s="polyline"===e.type?e.paths:e.rings,r=[],h=[0,0],u=new y;for(const i of s){const e=[];r.push(e),e.push([i[0][0],i[0][1]]);let s,a,o=i[0][0],c=i[0][1];for(let r=0;r<i.length-1;r++){if(s=i[r+1][0],a=i[r+1][1],o===s&&c===a)continue;const l=[o,c];b(u,[o,c],[s,a],n);const{azimuth:f,distance:p}=u,d=p/t;if(d>1){for(let i=1;i<=d-1;i++)R(h,l,f,i*t,n),e.push(h.slice());R(h,l,f,(p+Math.floor(d-1)*t)/2,n),e.push(h.slice())}R(h,l,f,p,n),e.push(h.slice()),o=h[0],c=h[1]}}const f=(0,a.PZ)(l.default,n);return"polyline"===e.type?new c.default({paths:r,spatialReference:f}):new o.default({rings:r,spatialReference:f})}class y{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.distance=e,this.azimuth=t,this.reverseAzimuth=n}}function R(e,t,n,i,s){const a=t[0],r=t[1],o=a*h.eh,c=r*h.eh,l=(n??0)*h.eh,{a:u,b:f,f:d}=p(s),g=Math.sin(l),m=Math.cos(l),M=(1-d)*Math.tan(c),w=1/Math.sqrt(1+M*M),v=M*w,y=Math.atan2(M,m),R=w*g,b=R*R,z=1-b,q=z*(u*u-f*f)/(f*f),S=1+q/16384*(4096+q*(q*(320-175*q)-768)),A=q/1024*(256+q*(q*(74-47*q)-128));let k,x,N,G=i/(f*S),C=2*Math.PI;for(;Math.abs(G-C)>1e-12;)N=Math.cos(2*y+G),k=Math.sin(G),x=Math.cos(G),C=G,G=i/(f*S)+A*k*(N+A/4*(x*(2*N*N-1)-A/6*N*(4*k*k-3)*(4*N*N-3)));const D=v*k-w*x*m,F=Math.atan2(v*x+w*k*m,(1-d)*Math.sqrt(b+D*D)),I=d/16*z*(4+d*(4-3*z)),U=Math.atan2(k*g,w*x-v*k*m)-(1-I)*d*R*(G+I*k*(N+I*x*(2*N*N-1)));return e[0]=(o+U)/h.eh,e[1]=F/h.eh,e}function b(e,t,n,i){const s=t[0]*h.eh,a=t[1]*h.eh,r=n[0]*h.eh,o=n[1]*h.eh,{a:c,b:l,f:u,radius:f}=p(i),d=r-s,g=Math.atan((1-u)*Math.tan(a)),m=Math.atan((1-u)*Math.tan(o)),M=Math.sin(g),w=Math.cos(g),v=Math.sin(m),y=Math.cos(m);let R,b,z,q,S,A,k,x,N,G,C=1e3,D=d;do{if(k=Math.sin(D),x=Math.cos(D),z=Math.sqrt(y*k*(y*k)+(w*v-M*y*x)*(w*v-M*y*x)),0===z)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;S=M*v+w*y*x,A=Math.atan2(z,S),N=w*y*k/z,b=1-N*N,q=S-2*M*v/b,isNaN(q)&&(q=0),G=u/16*b*(4+u*(4-3*b)),R=D,D=d+(1-G)*u*N*(A+G*z*(q+G*S*(2*q*q-1)))}while(Math.abs(D-R)>1e-12&&--C>0);if(0===C){const t=f,n=Math.acos(Math.sin(a)*Math.sin(o)+Math.cos(a)*Math.cos(o)*Math.cos(r-s))*t,i=r-s,c=Math.sin(i)*Math.cos(o),l=Math.cos(a)*Math.sin(o)-Math.sin(a)*Math.cos(o)*Math.cos(i),u=Math.atan2(c,l);return e.azimuth=u/h.eh,e.distance=n,e.reverseAzimuth=void 0,e}const F=b*(c*c-l*l)/(l*l),I=F/1024*(256+F*(F*(74-47*F)-128)),U=l*(1+F/16384*(4096+F*(F*(320-175*F)-768)))*(A-I*z*(q+I/4*(S*(2*q*q-1)-I/6*q*(4*z*z-3)*(4*q*q-3)))),_=Math.atan2(y*Math.sin(D),w*v-M*y*Math.cos(D)),P=Math.atan2(w*Math.sin(D),w*v*Math.cos(D)-M*y);return e.azimuth=_/h.eh,e.distance=U,e.reverseAzimuth=P/h.eh,e}function z(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"meters";if(!e||!t)throw new i.default("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!t.spatialReference)throw new i.default("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!(0,u.aI)(e.spatialReference,t.spatialReference))throw new i.default("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:a}=e;if(!m(a))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===t.x&&e.y===t.y)return new y(0,0,0);const r=new y;return b(r,[e.x,e.y],[t.x,t.y],a),r.distance=(0,s.oU)(r.distance,"meters",n),r.azimuth=d(r.azimuth),r.reverseAzimuth=d(r.reverseAzimuth),r}function q(e,t,n){if(!e||null==t||null==n)throw new i.default("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(n<0||n>360)throw new i.default("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0\xb0 to 360\xb0 degrees");if(!e.spatialReference)throw new i.default("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:s}=e;if(!m(s))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");const a=[0,0];return R(a,[e.x,e.y],n,t,s),new r.default({x:a[0],y:a[1],spatialReference:s})}function S(e){return m(e)?e:(0,u.K8)(e)?l.default.WGS84:null}}}]);
//# sourceMappingURL=7137.5e043a10.chunk.js.map